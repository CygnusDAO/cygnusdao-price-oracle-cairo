# ════════════════════════════════════════════════════════════════════════════════════════════════════════════════════
#                                       .           .
#      █████████           ---======*.                       .         ⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣠⣤⣴⣶⣶⣿⣿⣿⣿⣿⣷⣶⣶⣦⣤⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
#     ███░░░░░███                                              📡  .   ⠀⠀⣠⣦⣤⣤⣶⣶⣿⣿⣿⣿⣿⠿⠿⠟⠛⠛⠛⠛⠻⠿⠿⢿⣿⣿⣿⣶⣦⣤⣀⣀⣀⣠⣄⠀
#    ███     ░░░  █████ ████  ███████ ████████   █████ ████  █████  ⠀⠀ ⠀⢰⣿⣿⣿⣿⣿⣿⠿⠛⢉⣁⣠⣤⣴⣶⣶⣶⣶⣶⣤⣤⣤⣀⡀⠉⠛⠻⠿⣿⣿⣿⣿⣿⡿⠀
#   ░███         ░░███ ░███  ███░░███░░███░░███ ░░███ ░███  ███░░   ⠀⠀ ⠀⢀⡉⠛⣋⣉⣥⣴⣶⣿⣿⣿⣿⣿⠿⢿⣿⣿⣿⣿⣿⠿⠿⣿⣿⣷⣶⣤⣀⡀⠈⠉⠉⠉⠀⠀
#   ░███          ░███ ░███ ░███ ░███ ░███ ░███  ░███ ░███ ░░█████  ⠀⠀ ⠀⢾⣿⣿⣿⣿⣿⡿⠿⠛⠋⠉⠀⠀⠀⠈⢿⣿⣿⣿⡟⠀⠀⠀⠉⠛⠻⠿⣿⣿⣿⣿⣿⣿⣇⠀
#   ░░███     ███ ░███ ░███ ░███ ░███ ░███ ░███  ░███ ░███  ░░░░██  ⠀⠀ ⠀⠈⠛⠻⠿⠿⣿⣿⣷⣦⣄⣀⠀⠀⠀⠀⠀⠉⠉⠉⠀⠀⠀⢀⣀⣠⣴⣶⣿⣿⠿⠛⠛⠉⠉⠀
#    ░░█████████  ░░███████ ░░███████ ████ █████ ░░████████ ██████     ⠀⠀⠀⠀⠀⠀⠀⠈⠉⠛⠿⣿⣿⣿⣶⣶⣶⣶⣶⣴⣶⣶⣿⣿⣿⣿⢿⣿⠏⠀⠀⠀⠀⠀⠀
#     ░░░░░░░░░    ░░░░░███  ░░░░░███░░░░ ░░░░░   ░░░░░░░░ ░░░░░░   ⠀⠀ ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠉⠙⠛⠛⠻⠛⠛⢛⣻⣿⣿⠟⢁⣿⣿⠀⠀⠀⠀⠀⠀⠀
#                  ███ ░███  ███ ░███ ⠀⠀⠀⠀⠀⠀⠀.⠀⠀⠀⠀ ⠀ ⠀⠀ ⠀⠀.⠀⠀⠀⠀⠀⢀⠀⠀⢀⣴⣿⣿⣿⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣴⣿⡿⠛⠁⢀⣾⣿⣿⣀⠀⠀⠀⠀⠀⠀
#    .      *     ░░██████  ░░██████    ---===========*.               ⠀⣾⣿⡟⢹⣿⣿⣿⠄⠀⠀⠀⠀⠀⠀⠀⣀⣴⣿⣿⠟⠀⠀⠀⣼⣿⣿⣿⣿⣿⡶⠀⠀⠀⠀
#                  ░░░░░░    ░░░░░░                                    ⠀⣿⣿⠁⠈⠻⠿⠟⠀⠀⠀⠀⠀⢀⣠⣾⣿⡿⠟⠁⠀⠀⠀⢠⣿⣿⣿⣿⡿⠋⠀⠀⠀⠀⠀
#      .                           . ⠀    .                .           ⠀⠘⣿⣧⣄⡀⠀⠀⠀⣀⣠⣤⣶⣿⣿⠿⠋⠀⠀⠀⠀⠀⠀⣼⣿⣿⣿⠟⠁⠀⠀⠀⠀⠀⠀
#         https://cygnusdao.finance                  .                 ⠀⠀⠘⠿⣿⣿⣿⣿⣿⣿⣿⡿⠿⠋⠁⠀⠀⠀⠀⠀⠀⠀⠀⣿⣿⡿⠋⠀⠀⠀⠀⠀⠀⠀⠀
#                                    ⠀⠀⠀                               ⠀⠀⠀⠀⠀⠉⠉⠉⠉⠉⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢿⣿⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
#         Cygnus-Empiric: LP Price Oracle 𓂀                            ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠸⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
#
# ════════════════════════════════════════════════════════════════════════════════════════════════════════════════════

# SPDX-License-Identifier: Unlicensed
%lang starknet

# Cairo libraries
from starkware.cairo.common.math import assert_not_zero, assert_not_equal
from starkware.cairo.common.bool import FALSE, TRUE
from starkware.cairo.common.cairo_builtins import HashBuiltin
from starkware.cairo.common.pow import pow
from starkware.cairo.common.uint256 import Uint256, uint256_eq, uint256_le, uint256_lt

# Starkware syscalls
from starkware.starknet.common.syscalls import (
    get_caller_address,
    get_contract_address,
    get_block_timestamp,
)

# ════════════════════════════════════════════════════════════════════════════════════════════════════════════════════
#
# @title  cygnus_empiric_lp_oracle
# @author CygnusDAO
# @notice Oracle used by Cygnus that returns the price of 1 LP Token in DAI using Empiric price feeds. For a different
#         denomination variable (ie ETH) just deploy with ETH key in constructor
# @notice Implementation of fair lp token pricing using Empiric price feeds
#         https://blog.alphaventuredao.io/fair-lp-token-pricing/
#
# ════════════════════════════════════════════════════════════════════════════════════════════════════════════════════

# Libraries
from src.cygnus_oracle.libraries.math_ud58x18 import MathUD58x18  # Custom library -> not thoroughly tested
from src.cygnus_oracle.libraries.reentrancy_guard import ReentrancyGuard

# interfaces
from src.cygnus_oracle.interfaces.interface_erc20 import IERC20
from src.cygnus_oracle.interfaces.interface_dex_pair import IPair
from src.cygnus_oracle.interfaces.interface_empiric_oracle import IEmpiricOracle

# ════════════════════════════════════════════════════════════════════════════════════════════════════════════════════
#     1. STRUCTS
# ════════════════════════════════════════════════════════════════════════════════════════════════════════════════════

#
# @custom:struct CygnusEmpiricLPOracle Official record of all LP Token oracles used by Cygnus
# @custom:member oracleId The ID of the LP Token tracked by the oracle
# @custom:member initialized Whether an LP Token is being tracked or not
# @custom:member lp_token_pair The address of the LP Token
# @custom:member empiric_key_token0 The unique key Empiric uses for the price feed of this lp_token_pair`s token0
# @custom:member empiric_key_token1 The unique key Empiric uses for the price feed of this lp_token_pair`s token1
# @custom:member initialized_timestamp The unix timestamp at which this oracle was initialized
# @custom:member deletion_timestamp The unix timestamp at which this oracle was disabled or set to default (all 0's)
#
struct CygnusEmpiricLPOracle:
    member oracle_id : felt
    member initialized : felt
    member empiric_key_token0 : felt
    member empiric_key_token1 : felt
end

# ════════════════════════════════════════════════════════════════════════════════════════════════════════════════════
#     2. CUSTOM EVENTS
# ════════════════════════════════════════════════════════════════════════════════════════════════════════════════════

#
# @notice Logs when an oracle is initialized for an LP Token
# @custom:event InitializeCygnusOracle Emitted when the oracle is initialized
# @return new_nebula_oracle The struct with all the info of the initialized oracle
#
@event
func InitializeCygnusOracle(new_nebula_oracle : CygnusEmpiricLPOracle):
end

#
# @notice Logs when an oracle is deleted for an LP Token
# @custom:event DeleteCygnusOracle Emitted when an oracle is deleted (or set all back to defaults 0)
# @return deleted_nebula_oracle The deleted struct
#
@event
func DeleteCygnusOracle(deleted_nebula_oracle : CygnusEmpiricLPOracle):
end

#
# @notice Logs when a new oracle pending admin is set
# @param pending_admin The address of the pending admin, to be accepted as the new oracle admin
# @param admin The address of the current admin, to accept the pending admin
#
@event
func NewPendingAdmin(pending_admin : felt, admin : felt):
end

#
# @notice Logs when a new oracle admin is set
# @param old_admin The address of the old oracle admin
# @param admin The address of the new oracle admin
#
@event
func NewAdmin(old_admin : felt, admin : felt):
end

# ════════════════════════════════════════════════════════════════════════════════════════════════════════════════════
#     3. STORAGE
# ════════════════════════════════════════════════════════════════════════════════════════════════════════════════════

# ─────────────────────────────────────────────────── Internal ───────────────────────────────────────────────────────

# Constants ─────────────────────────────────────────

#
# Oracle Interface Definition
#
const EMPIRIC_ORACLE_ADDRESS = 0x012fadd18ec1a23a160cc46981400160fbf4a7a5eed156c4669e39807265bcd4

#
# Aggregation mode -> Median
#
const AGGREGATION_MODE = 120282243752302

# Single storage ────────────────────────────────────

# # Metadata

#
# @notice Stored name of this oracle
# @return Name of this oracle - `Cygnus-Empiric: LP Price Oracle`
#
@storage_var
func Name() -> (name : felt):
end

#
# @notice Stored symbol of this oracle
# @return symbol The symbol of the oracle - `EMPIRIC-LP-ORACLE`
#
@storage_var
func Symbol() -> (symbol : felt):
end

#
# @notice Stored decimals that this oracle returns the price in
# @return decimals How many trailing decimals can be represented (set to 18 in the constructor)
#
@storage_var
func Decimals() -> (decimals : felt):
end

#
# @return version The stored version number of this oracle
#
@storage_var
func Version() -> (version : felt):
end

# # Important addresses

#
# @return admin The stored address of the oracle admin
#
@storage_var
func Admin() -> (admin : felt):
end

#
# @return pending_admin The stored adress of the oracle pending admin
#
@storage_var
func Pending_Admin() -> (pending_admin : felt):
end

#
# @notice Denomination token of this price oracle
# @return dai The unique key of empiric representing the denomination token
#
@storage_var
func Dai() -> (dai : felt):
end

# Mapping storage ───────────────────────────────────

#
# @notice Unique key/value storage of LP Token oracles
# @param lp_token_pair The address of the LP Token
# @return CygnusEmpiricLPOracle The struct containing the info and price feeds used for the lp_token_pair
#
@storage_var
func Oracles(lp_token_pair : felt) -> (CygnusEmpiricLPOracle : CygnusEmpiricLPOracle):
end

#
# @notice Simple counter++
# @return total_oracles The total number of initialized oracles
#
@storage_var
func Total_Oracles() -> (total_oracles : felt):
end

# ════════════════════════════════════════════════════════════════════════════════════════════════════════════════════
#     4. CONSTRUCTOR
# ════════════════════════════════════════════════════════════════════════════════════════════════════════════════════

#
# @notice Constructs the LP oracle with Empiric`s price feeds. Sets initial storage values:
#           - Name, decimals and symbol of oracle
#           - Admin address
#           - Empiric`s unique key for denomination token (in our case, Dai)
#           - Oracle version
#
# @param admin The address of the oracle admin
# @param price_denominator Empiri`s kay for the denomination this oracle returns the prices in # 28254602066752356
#
@constructor
func constructor{syscall_ptr : felt*, pedersen_ptr : HashBuiltin*, range_check_ptr}(
    admin : felt, price_denominator : felt
):
    #
    # ERORR: Doesn`t get deployed
    #
    assert_not_zero(admin * price_denominator)

    # name of this oracle
    Name.write(value='Cygnus-Empiric: LP Price Oracle')

    # symbol used by this oracle
    Symbol.write(value='CygNebula')

    # decimals that the oracle returns the prices in
    Decimals.write(value=18)

    # store the address of the admin to add LP Tokens
    Admin.write(value=admin)

    # store the key from Empiric for denom token
    Dai.write(value=price_denominator)

    # store the version
    Version.write(value=1)

    return ()
end

# ════════════════════════════════════════════════════════════════════════════════════════════════════════════════════
#     5. STORAGE ACCESSORS
# ════════════════════════════════════════════════════════════════════════════════════════════════════════════════════

# ─────────────────────────────────────────────────── External ───────────────────────────────────────────────────────

# single storage ────────────────────────────────────

#
# @notice Getter for the stored namne of this oracle
# @return name The name of this oracle `Empiric LP Oracle`
#
@view
func name{syscall_ptr : felt*, pedersen_ptr : HashBuiltin*, range_check_ptr}() -> (name : felt):
    return Name.read()
end

#
# @notice Getter for the stored symbol
# @return symbol The symbol used to represent this oracle `EMP-LP-ORACLE`
#
@view
func symbol{syscall_ptr : felt*, pedersen_ptr : HashBuiltin*, range_check_ptr}() -> (symbol : felt):
    return Symbol.read()
end

#
# @notice Getter for the stored decimals
# @return decimals How many trailing decimals can be represented
#
@view
func decimals{syscall_ptr : felt*, pedersen_ptr : HashBuiltin*, range_check_ptr}() -> (
    decimals : felt
):
    return Decimals.read()
end

#
# @notice Getter for this oracle`s version
# @return version The version of this oracle (v1)
#
@view
func version{syscall_ptr : felt*, pedersen_ptr : HashBuiltin*, range_check_ptr}() -> (
    version : felt
):
    return Version.read()
end

#
# @notice Getter for this oracle`s denomination token
# @return dai The address of Dai on starknet
#
@view
func dai{syscall_ptr : felt*, pedersen_ptr : HashBuiltin*, range_check_ptr}() -> (dai : felt):
    return Dai.read()
end

#
# @notice Getter for the stored admin
# @return admin The current admin of this oracle
#
@view
func admin{syscall_ptr : felt*, pedersen_ptr : HashBuiltin*, range_check_ptr}() -> (admin : felt):
    return Admin.read()
end

#
# @notice Getter for the stored pending admin
# @return pending_admin The pending admin currently set (default 0)
#
@view
func pending_admin{syscall_ptr : felt*, pedersen_ptr : HashBuiltin*, range_check_ptr}() -> (
    pending_admin : felt
):
    return Pending_Admin.read()
end

#
# @notice Returns the total amount of oracles we currently have, a simple counter
#
@view
func total_oracles{syscall_ptr : felt*, pedersen_ptr : HashBuiltin*, range_check_ptr}() -> (
    total_oracles : felt
):
    return Total_Oracles.read()
end

# Constants ─────────────────────────────────────────

#
# @notice Getter for the constant to view current empiric oracle address we are using
# @return empiric_oracle_address The address of Empiric's oracle
#
@view
func empiric_oracle_address() -> (empiric_oracle_address : felt):
    return (empiric_oracle_address=EMPIRIC_ORACLE_ADDRESS)
end

#
# @notice Getter for the constant to view this oracle`s used aggregation mode
# @return aggregation_mode This oracles aggregation mode
#
@view
func aggregation_mode() -> (aggregation_mode : felt):
    return (aggregation_mode=AGGREGATION_MODE)
end

# mapping storage ───────────────────────────────────

#
# @notice Getter for the mapping to return the oracle struct
# @return CygnusEmpiricLPOracle The recorded info of this LP Token`s oracle (if any)
#
@view
func get_price_oracle{syscall_ptr : felt*, pedersen_ptr : HashBuiltin*, range_check_ptr}(
    lp_token_pair : felt
) -> (CygnusEmpiricLPOracle : CygnusEmpiricLPOracle):
    return Oracles.read(lp_token_pair=lp_token_pair)
end


# ════════════════════════════════════════════════════════════════════════════════════════════════════════════════════
#     6. CONSTANT FUNCTIONS
# ════════════════════════════════════════════════════════════════════════════════════════════════════════════════════

# ─────────────────────────────────────────────────── Internal ───────────────────────────────────────────────────────

#
# @notice Reverts if msg.sender is not admin
#
func oracle_admin_internal{syscall_ptr : felt*, pedersen_ptr : HashBuiltin*, range_check_ptr}():
    # get msg.sender
    let (caller : felt) = get_caller_address()

    # factory admin address
    let (cygnus_admin : felt) = Admin.read()

    #
    # ERROR: caller_not_admin
    #
    with_attr error_message("empiric_lp_oracle__caller_not_admin()"):
        # check caller not 0 address
        assert_not_zero(caller)
        # check caller is cygnus admin, else revert
        assert caller = cygnus_admin
    end

    return ()
end

#
# @notice It scales reseves of any token to 18 decimals. This is needed because not all tokens have the same
#         decimals, and calculation the total balance $ of a pool based on different reserve decimals yields
#         incorrect results (ie USDC 6 decimals)
#
# @param token The address of token0 or token1 from the LP Token
# @param reserves The reserves of token0 or token1 in the liquidity pool
# @return adjusted_reserves `reserves` of token0 or token1 scaled to 18 decimals (if needed)
#
func normalize_reserves{syscall_ptr : felt*, pedersen_ptr : HashBuiltin*, range_check_ptr}(
    token : felt, reserves : felt
) -> (adjusted_reserves : felt):
    # ap += SIZEOF_LOCALS
    alloc_locals

    # the decimals used by this ERC20 token
    let (token_decimals : felt) = IERC20.decimals(contract_address=token)

    # explicitly get the decimals from the oracle (avoid setting fixed `18`, future problems)
    let (oracle_decimals : felt) = Decimals.read()

    # get the decimal difference (if any) -> sub reverts if y > x
    let (decimal_difference : felt) = MathUD58x18.sub(x=oracle_decimals, y=token_decimals)

    # adjust decimals and checks for overflow
    let (adjusted_decimals : felt) = pow(10, decimal_difference)

    # Adjust reserves ie. if `token` has 12 decimals, adjusted_reserves = reserves * 1000000
    let (adjusted_reserves : felt) = MathUD58x18.mul(x=reserves, y=adjusted_decimals)

    return (adjusted_reserves=adjusted_reserves)
end

#
# @notice Same as normalize reserves, but normalize the price with decimals
# @param price The price from Empiric`s price feed
# @return token_decimals The decimals of empiric`s price feed for this token
# @return adjusted_price The price adjutes to 18 decimals (if needed)
#
func normalize_price{syscall_ptr : felt*, pedersen_ptr : HashBuiltin*, range_check_ptr}(
    price : felt, token_decimals : felt
) -> (adjusted_price : felt):
    alloc_locals

    # explicitly get the decimals from the oracle (avoid setting fixed `18`, future problems)
    let (oracle_decimals : felt) = Decimals.read()

    # get the decimal difference (if any)
    let (decimal_difference : felt) = MathUD58x18.sub(x=oracle_decimals, y=token_decimals)

    # adjust decimals and checks for overflow
    let (adjusted_decimals : felt) = pow(10, decimal_difference)

    # adjust price (if necessary)
    let (adjusted_price : felt) = MathUD58x18.mul(x=price, y=adjusted_decimals)

    return (adjusted_price=adjusted_price)
end

# ─────────────────────────────────────────────────── External ───────────────────────────────────────────────────────

#
# @notice Getter for dai price (or denom_token) used for simplicity.
# @return dai_price The price of dai from Empiric
# @return dai_decimals The decimals used for this price feed, used to normalize later if need be
#
@view
func get_dai_price{syscall_ptr : felt*, pedersen_ptr : HashBuiltin*, range_check_ptr}() -> (
    dai_price : felt, dai_decimals : felt
):
    # get dei unique key
    let (dai : felt) = Dai.read()

    # get the price of Dai from Empiric
    let (dai_price, dai_decimals, _, _) = IEmpiricOracle.get_value(
        EMPIRIC_ORACLE_ADDRESS, dai, AGGREGATION_MODE
    )

    return (dai_price=dai_price, dai_decimals=dai_decimals)
end

#
# @notice Gets the prices of both assets from an LP Token from Empiric price feeds
# @param lp_token_pair The address of the LP Token
# @return token0_price The price of token 0
# @return token1_price The price of token 1
#
@view
func get_asset_prices{syscall_ptr : felt*, pedersen_ptr : HashBuiltin*, range_check_ptr}(
    lp_token_pair : felt
) -> (token0_price : felt, token1_price : felt):
    # Load oracle from mapping
    let (cygnus_nebula : CygnusEmpiricLPOracle) = get_price_oracle(lp_token_pair=lp_token_pair)

    #
    # ERROR: oracle_not_initialized
    #
    with_attr error_message("empiric_lp_oracle__oracle_not_initialized({lp_token_pair})"):
        # require initialized == TRUE
        assert cygnus_nebula.initialized = TRUE
    end

    # price of token0 from this LP Token
    let (token0_price : felt, _, _, _) = IEmpiricOracle.get_value(
        EMPIRIC_ORACLE_ADDRESS, cygnus_nebula.empiric_key_token0, AGGREGATION_MODE
    )

    # price of token1 from this LP Token
    let (token1_price : felt, _, _, _) = IEmpiricOracle.get_value(
        EMPIRIC_ORACLE_ADDRESS, cygnus_nebula.empiric_key_token1, AGGREGATION_MODE
    )

    return (token0_price, token1_price)
end

#
# @notice Calculates the price of 1 unit of the lp_token_pair in DAI
#
@view
func get_lp_token_price{syscall_ptr : felt*, pedersen_ptr : HashBuiltin*, range_check_ptr}(
    lp_token_pair : felt
) -> (lp_token_price : felt):
    alloc_locals

    # 1. ────────────── Get stored LP Token Oracle ──────────────────────────

    # Load oracle from mapping
    let (cygnus_nebula : CygnusEmpiricLPOracle) = get_price_oracle(lp_token_pair=lp_token_pair)

    #
    # ERROR: oracle_not_initialized
    #
    with_attr error_message("empiric_lp_oracle__oracle_not_initialized({lp_token_pair})"):
        # require initialized == TRUE
        assert cygnus_nebula.initialized = TRUE
    end

    # 2. ────────────── Get token0 and token1 from LP ───────────────────────

    # get the token0 from the lp token
    let (token0 : felt) = IPair.token0(contract_address=lp_token_pair)

    # Get the token1 from the lp token
    let (token1 : felt) = IPair.token1(contract_address=lp_token_pair)

    # 3. ────────────── Normalize reserves (if necessary) ───────────────────

    # get reserves of token0 and token 1 from liquidity pool
    let (token0_reserves : Uint256, token1_reserves : Uint256, _) = IPair.get_reserves(
        contract_address=lp_token_pair
    )

    # pass token0 address and reserves to account for difference in decimals (if any)
    let (token0_adjusted_reserves : felt) = normalize_reserves(token0, token0_reserves.low)

    # pass token1 address and reserves to account for difference in decimals (if any)
    let (token1_adjusted_reserves : felt) = normalize_reserves(token1, token1_reserves.low)

    #
    # ERROR: reserves_not_zero
    #
    with_attr error_message("empiric_lp_oracle__invalid_reserves({lp_token_pair})"):
        # avoid 0 reserves from either token0 or token1
        assert_not_zero(token0_adjusted_reserves * token1_adjusted_reserves)
    end

    # 4. ────────────── Calculate fair reserves ─────────────────────────────

    # sqrt(reserves0*reserves1)
    # Using a custom library -> not thoroughly checked yet
    let (reserves_gm : felt) = MathUD58x18.gm(token0_adjusted_reserves, token1_adjusted_reserves)

    # 5. ────────────── Prices from Empiric ─────────────────────────────────

    # get price of token0 from Empiric
    let (token0_price : felt, token0_decimals : felt, _, _) = IEmpiricOracle.get_value(
        EMPIRIC_ORACLE_ADDRESS, cygnus_nebula.empiric_key_token0, AGGREGATION_MODE
    )

    # get price of token1 from Empiric
    let (token1_price : felt, token1_decimals : felt, _, _) = IEmpiricOracle.get_value(
        EMPIRIC_ORACLE_ADDRESS, cygnus_nebula.empiric_key_token1, AGGREGATION_MODE
    )

    # account for decimal difference between price feed and decimals
    let (token0_price_adjusted : felt) = normalize_price(token0_price, token0_decimals)

    # account for decimal difference between price feed and decimals
    let (token1_price_adjusted : felt) = normalize_price(token1_price, token1_decimals)

    # 6. ────────────── Calculate fair price ────────────────────────────────

    # sqrt(price0*price1)
    let (prices_gm : felt) = MathUD58x18.gm(token0_price_adjusted, token1_price_adjusted)

    # 7. ────────────── LP Token Price in USD (feeds) ──────────────────────

    # price / total LP Token supply

    # LP Token's total supply
    let (total_supply : Uint256) = IPair.totalSupply(contract_address=lp_token_pair)

    # half price of what should be in the liquidity pool
    let (half_price : felt) = MathUD58x18.mul_div(reserves_gm, prices_gm, total_supply.low)

    # total price in the pool in USD (price feeds)
    let (lp_token_price_usd : felt) = MathUD58x18.mul(half_price, 2)

    # 8. ────────────── LP Token Price in Dai ───────────────────────────────

    # get price of denomination token (DAI)
    let (dai_price : felt, dai_decimals : felt) = get_dai_price()

    # account for decimal difference between price feed and decimals
    let (dai_price_adjusted : felt) = normalize_price(dai_price, dai_decimals)

    # adjust price to be denominated in DAI
    let (lp_token_price : felt) = MathUD58x18.mul_div(
        lp_token_price_usd, 10 ** 18, dai_price_adjusted
    )

    # return the price of 1 LP Token of the underlying in DAI
    return (lp_token_price)
end

# ════════════════════════════════════════════════════════════════════════════════════════════════════════════════════
#     7. NON-CONSTANT FUNCTIONS
# ════════════════════════════════════════════════════════════════════════════════════════════════════════════════════

# ─────────────────────────────────────────────────── External ───────────────────────────────────────────────────────

#
# @notice Admin only 👽
# @notice Initializes the oracle for an LP Token pair
# @param lp_token_pair The address of the uniswap-v2 compatible LP Token pair
# @param empiric_key_token0 The unique key Empiric uses to identifiy this LP Token's token0
# @param empiric_key_token1 The unique key Empiric uses to identifiy this LP Token's token1
# @custom:security non-reentrant
#
@external
func initialize_oracle{syscall_ptr : felt*, pedersen_ptr : HashBuiltin*, range_check_ptr}(
    lp_token_pair : felt, empiric_key_token0 : felt, empiric_key_token1
):
    # lock
    ReentrancyGuard._start()

    # revert if not admin
    oracle_admin_internal()

    # load oracle of this LP Token from mapping (if any)
    let (new_oracle : CygnusEmpiricLPOracle) = get_price_oracle(lp_token_pair)

    #
    # ERROR: oracle_already_initialized
    #
    with_attr error_message("empiric_lp_oracle__oracle_already_initialized({lp_token_pair})"):
        # check 0
        assert_not_zero(lp_token_pair)

        # check if initialized
        assert new_oracle.initialized = FALSE
    end

    # not initialized, update to storage

    # get current length = id
    let (number_of_oracles : felt) = Total_Oracles.read()

    # create new oracle struct
    let store_new_oracle = CygnusEmpiricLPOracle(
        oracle_id=number_of_oracles,
        initialized=1,
        empiric_key_token0=empiric_key_token0,
        empiric_key_token1=empiric_key_token1,
    )

    # write new oracle struct to storage
    Oracles.write(lp_token_pair, store_new_oracle)

    # add id counter
    Total_Oracles.write(number_of_oracles + 1)

    #
    # EVENT: InitializeCygnusOracle
    #
    InitializeCygnusOracle.emit(store_new_oracle)

    # unlock
    ReentrancyGuard._end()

    return ()
end

#
# @notice Admin only 👽
# @notice Deletes an oracle for an LP Token pair in case we need to update (otherwise initialize_oracle reverts)
# @param lp_token_pair The address of the uniswap-v2 compatible LP Token pair
# @custom:security non-reentrant
#
@external
func delete_oracle{syscall_ptr : felt*, pedersen_ptr : HashBuiltin*, range_check_ptr}(
    lp_token_pair : felt
):
    # lock
    ReentrancyGuard._start()

    # revert if not admin
    oracle_admin_internal()

    # read oracle from mapping
    let (oracle : CygnusEmpiricLPOracle) = get_price_oracle(lp_token_pair)

    # get current length = id
    let (number_of_oracles : felt) = Total_Oracles.read()

    #
    # ERROR: oracle_not_initialized
    #
    with_attr error_message("empiric_lp_oracle__oracle_not_initialized({lp_token_pair})"):
        # check 0
        assert_not_zero(lp_token_pair)

        # require initialized == TRUE
        assert oracle.initialized = TRUE
    end

    # create new oracle struct
    let delete_oracle = CygnusEmpiricLPOracle(
        oracle_id=number_of_oracles, initialized=0, empiric_key_token0=0, empiric_key_token1=0
    )

    # write new empty oracle struct to storage, dont decrease total oracle counter or else mess up ids
    Oracles.write(lp_token_pair, delete_oracle)

    #
    # EVENT: DeleteCygnusOracle
    #
    DeleteCygnusOracle.emit(oracle)

    # unlock
    ReentrancyGuard._end()

    return ()
end

#
# @notice Admin only 👽
# @notice Sets a new pending admin to be accepted by the current admin
# @param new_pending_admin The address of the new pending admin
# @custom:security non-reentrant
#
@external
func set_oracle_pending_admin{syscall_ptr : felt*, pedersen_ptr : HashBuiltin*, range_check_ptr}(
    new_pending_admin : felt
):
    # lock
    ReentrancyGuard._start()

    # revert if not admin
    oracle_admin_internal()

    # address of current admin
    let (admin : felt) = Admin.read()

    #
    # ERROR: admin_already_set
    #
    with_attr error_message("empiric_lp_oracle__admin_already_set()"):
        assert_not_equal(new_pending_admin, admin)
    end

    # write to storage
    Pending_Admin.write(value=new_pending_admin)

    #
    # EVENT: NewPendingAdmin
    #
    NewPendingAdmin.emit(pending_admin=new_pending_admin, admin=admin)

    # unlock
    ReentrancyGuard._end()

    return ()
end

#
# @notice Admin only 👽
# @notice accepts the pending admin and resigns privileges
# @custom:security non-reentrant
#
@external
func set_oracle_admin{syscall_ptr : felt*, pedersen_ptr : HashBuiltin*, range_check_ptr}():
    # lock
    ReentrancyGuard._start()

    # revert if not admin
    oracle_admin_internal()

    # get pending admin
    let (new_admin : felt) = Pending_Admin.read()

    #
    # ERROR: admin_already_set
    #
    with_attr error_message("empiric_lp_oracle__admin_cant_be_zero()"):
        assert_not_zero(new_admin)
    end

    # address of the current admin
    let (old_admin : felt) = Admin.read()

    # assign new admin
    Admin.write(value=new_admin)

    # remove pending admin back to 0
    Pending_Admin.write(0)

    #
    # EVENT: NewAdmin
    #
    NewAdmin.emit(old_admin=old_admin, admin=new_admin)

    # unlock
    ReentrancyGuard._end()

    return ()
end
